package org.qubership.cloud.routesregistration.common.gateway.route.transformation;

import org.qubership.cloud.routesregistration.common.annotation.processing.ClassRoutesBuilder;
import org.qubership.cloud.routesregistration.common.gateway.route.Constants;
import org.qubership.cloud.routesregistration.common.gateway.route.RouteEntry;
import org.qubership.cloud.routesregistration.common.gateway.route.RouteType;
import lombok.RequiredArgsConstructor;

import java.util.*;

@RequiredArgsConstructor
public class RouteTransformer {
    private final String microserviceName;

    public Collection<RouteEntry> transform(Collection<RouteEntry> routeEntries) {
        final List<RouteEntry> result = new ArrayList<>(routeEntries.size());
        for (RouteEntry routeEntry: routeEntries) {
            // set route type explicitly in case it was not specified yet
            routeEntry.setType(resolveActualRouteType(routeEntry));

            if (routeEntry.getType() == RouteType.FACADE) {
                addMeshRoute(result, routeEntry);
            } else { // all the other types are border gateway types
                addBorderGatewayRoutes(result, routeEntry);
            }
        }
        return validateAndReturnRoutes(result);
    }

    /**
     * <p>Builds set containing all the effective microservice routes based on the provided routes
     * and {@link ClassRoutesBuilder} instances.</p>
     *
     * <p>Preforms validation of each route and fails with {@code IllegalArgumentException} in case of collisions.</p>
     *
     * @param routes list of all the microservice routes to be validated
     * @return set of all the microservice routes.
     * @throws IllegalArgumentException in case of route collisions.
     */
    private Collection<RouteEntry> validateAndReturnRoutes(List<RouteEntry> routes) {
        final Set<RouteEntry> resultingSet = new HashSet<>(routes.size());
        routes.forEach(route -> { // validate each route before adding it to resulting set
            boolean shouldAddRoute = true;
            for (RouteEntry alreadyAddedRoute : resultingSet) {
                if (route.equals(alreadyAddedRoute)) { // routes are equal if they have same gateway and matcher
                    if (route.isAllowed() != alreadyAddedRoute.isAllowed()) {
                        // prefer allowed route since all forbidden routes are autogenerated by the library
                        shouldAddRoute = route.isAllowed();
                    } else if (!route.getTo().equals(alreadyAddedRoute.getTo())) {
                        String errorMessage = String.format("It's not supported to have several target paths for forwarding from the same source path! Check %s routes for path %s", route.getType().name(), route.getFrom());
                        throw new IllegalArgumentException(errorMessage);
                    }
                }
            }
            if (shouldAddRoute) {
                resultingSet.add(route);
            }
        });
        return resultingSet;
    }

    private void addMeshRoute(Collection<RouteEntry> result, RouteEntry route) {
        String gateway = resolveMeshGatewayName(route);
        // by this moment we can override gateway field since we have already calculated effective route type
        route.setGateway(gateway);
        result.add(route);
    }

    private void addBorderGatewayRoutes(Collection<RouteEntry> result, RouteEntry route) {
        result.add(createBorderGatewayRoute(route, Constants.PUBLIC_GATEWAY_SERVICE));
        result.add(createBorderGatewayRoute(route, Constants.PRIVATE_GATEWAY_SERVICE));
        result.add(createBorderGatewayRoute(route, Constants.INTERNAL_GATEWAY_SERVICE));
    }

    private RouteEntry createBorderGatewayRoute(RouteEntry route, String gateway) {
        // create actual border gateway route from RouteEntry
        RouteEntry actualRoute = new RouteEntry(route);
        actualRoute.setGateway(gateway);
        actualRoute.setAllowed(resolveIsRouteAllowed(route, gateway));
        return actualRoute;
    }

    private boolean resolveIsRouteAllowed(RouteEntry routeEntry, String gateway) {
        if (!routeEntry.isAllowed()) return false;
        switch (routeEntry.getType()) {
            case PUBLIC:
                return Constants.PUBLIC_GATEWAY_SERVICE.equals(gateway)
                        || Constants.PRIVATE_GATEWAY_SERVICE.equals(gateway)
                        || Constants.INTERNAL_GATEWAY_SERVICE.equals(gateway);
            case PRIVATE:
                return Constants.PRIVATE_GATEWAY_SERVICE.equals(gateway)
                        || Constants.INTERNAL_GATEWAY_SERVICE.equals(gateway);
            case INTERNAL:
                return Constants.INTERNAL_GATEWAY_SERVICE.equals(gateway);
            default:
                throw new IllegalArgumentException("Unsupported route type " + routeEntry.getType() + " for RouteTransformer#resolveIsRouteAllowed!");
        }
    }

    private RouteType resolveActualRouteType(RouteEntry routeEntry) {
        if (routeEntry.getType() == null || routeEntry.getType() == RouteType.INTERNAL) {
            // this might be a default value, so check gateway field
            if (routeEntry.getGateway() == null || routeEntry.getGateway().isEmpty()) {
                return RouteType.INTERNAL; // default route type is INTERNAL
            } else { // gateway name is specified
                return RouteType.fromGatewayName(routeEntry.getGateway());
            }
        }
        return routeEntry.getType();
    }

    private String resolveMeshGatewayName(RouteEntry routeEntry) {
        if (routeEntry.getGateway() == null || routeEntry.getGateway().isEmpty()) {
            return microserviceName;
        }
        return routeEntry.getGateway();
    }
}
